---
title: Dates and Appointments
week: 8
assigned: 2018-08-02
due: 2018-08-02
---

* This will be a TOC
{:toc}

* The work prescribed in this studio will probably exceed the time
you have today.  

	**Work as slowly as required to understand what you are doing.**
	
	You receive credit no matter how far you go with this studio.  If there are steps beyond the time you have today, look at those on your own.

* If you need further help, ask a TA or the professor as needed.

# Warmup
* First, form a group:
* All but one member of your group should have this web page open so you can follow along and see the instructions as you work
* Plan to have one computer at which your team does its work. Initially, one of you will be in charge of typing at that computer.
* Throughout the studio, you should trade who is in charge of the keyboard. Before doing so, **commit your work** to make sure your work is saved

#Procedure
From the story described below, design and implement the described classes. Follow the instructions carefully. Don\'t rush ahead until you have successfully completed the specified work.

1. Read the following:

	* A `Date` has-a month, day, and year.  It also has-a field that indicates whether the date is a holiday or not.

	For the purposes of this studio, assume that all months have 31 days.

	* A `Time` has-an hour (0 to 23) and a minute (0 to 59).  It also has-a field that indicates whether the (`toString()` of the) time should be in 12- or 24-hour format.

2. At this point, create an immutable class for `Date` and `Time` in your `studio8` package of the `studios` source folder, based on the above story.
 
	* The term *immutable* means that the instance variables cannot change after the object is constructed.  `Color` is such an object, but `Account`  is not.

	To show your intent about immutability, be sure to include the keyword `final` in your instance variable declarations, as in:

	<PRE>
	  private final int x;
	</PRE>

	If this is unclear, ask around about it.

	* For now, assume that only legitimate input values are specified for anything your constructor requires.

	* Think carefully about what your constructor for `Time` should retain.  Explore a bit how you will deal with the 12- or 24-hour format issue for `toString()`.  

		* What is the essence of such a `Time` object? 

		* What instance variables are required to capture its essence?

3. Now implement `toString()` for each of these classes, returning a String that is appropriately descriptive.

4. Create a few instances and print them out in the `main` method of the each class.


5. **Show a TA your work so far.**

6. We next equip our two classes with the ability to tell whether they do, or do not *equal* a given `Object`.

	For each of the two classes, let\'s make eclipse generate the `equals` and `hashCode` methods.  You won\'t understand all of that just yet, but let\'s do it and we\'ll explainthings later:

	1. While editing each class, choose `Source`..`Generate hashCode() and equals()`..

	2. You are then presented with a menu of instance variables.

	This is an important step for you.  You must decide *which* of the instance variables (fields) should be used to compare two objects of this kind.

	These classes were specified such that **not all** of the fields are relevant for this comparsion.  Talk this over, make your choices, and then....

	3. Click `OK`.

	4. Take a look at the code that is generated.  Again, it probably will not
	make much sense, so please consider the following as you look at the code:

	`hashCode()`

	For whichever fields you have chosen for equality considerations, it must always be the case that if two objects do equal each other, then they have the same `hashCode()` value.  This implication goes only in the direction stated, so one possible legal implementation is simply:

	<PRE>
	public int hashCode() {
	   return 0;
	}
	</PRE>


	However, you can see that the code eclipse generated is much more complicated than that.

	For now, imagine that you have before you lots of buckets, each labeled with an integer.  Think of `hashCode()` as returning an integer that represents the only bucket in which this object could be found.  Thus, if you want to see if the object exists in all of the buckets, you really need only check one bucket.

	Convince yourself that if two objects of the same type (for example, `Date`) equal each other, then their `hashCode()` values are the same as computed by the eclipse-generated code.

	You might also try to find two objects of the same type such that they differ and their `hashCode()` values happen to be different.

	`equals(Object obj)`

	With regard to the code automatically generated for `equals(Object obj)`, the <a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/Object.html#equals%28java.lang.Object%29">contract in Java for equals</a> includes the following;  read over the code and convince yourselves that the code enacts the proper contract:

	* If `this` and `obj` are physically the same object, then the result should be `true`.
	* No instantiated object equals the `null` reference. The `this` reference is always to an actually instantiated object.
	* If `this` and `obj` are objects of different types, then the answer must be `false`.
	* If none of the above rules applies, then equality can be based on any consistent comparison of any subset of the objects\' fields.

7. Instantiate some `Date` and `Time` objects (several of each) and ensure that they compare properly to each other.

	Remember to use `a.equals(b)` to see if `a` and `b` equal each other!  If you use `==`, the comparison is restricted to whether the two objects are phyiscally the same:  the `equals(Object obj)` method is not run for that comparison.


8. Let\'s now make some lists and sets of the objects we have created so far. We\'ll focus on `Date` but if you have time, try this with `Time` as well (pardon the pun).

	1. In the `main` method of each class, you should already be creating and comparing instances of your objects.
	
	2. After you have instantiated some 5 objects, create a `List` of such objects by using the following code:

	<PRE>
	LinkedList&lt;Date&gt; list = new LinkedList&lt;Date&gt;();
	</PRE>

	You have not seen the angle-bracket notation. It is used to specify parametric types.  It may help to read the above line of code as:

	Instantiate a new linked list of Date objects and assign that object to the variable named `list`.

	You may have to use eclipse suggestions to import the proper classes, which will come from the `java.util` package.


9. What can we do with a [LinkedList](http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html) object?  Click on the link in the sentence before this one and check out the API.

	Note that in the documentation, `E` refers to the type of element in the list you construct.  In this running example, that would be a `Date` object.

10. Add some of your `Date` objects to the `list` list and print it out whenyou are done.

	To print it you need only say:
	
	<PRE>
	System.out.println(list);
	</PRE>

11. **Show your work to a TA.**

12. Let\'s see what happens when we add two `Date` objects to the list that `equal` each other:

	<PRE>
	Date d1 = new Date(...stuff your constructor needs);
	Date d2 = new Date(...same info as above, so these will equal each other);
	list.add(d1);
	list.add(d2);
	list.add(d1);
	System.out.println(list);
	</PRE>

	What do you see?  Does the same date appear three times in the list?

13. Let\'s do the same thing but this time with a `HashSet`. After the code you have written so far, add:

	<PRE>
	HashSet&lt;Date&gt; set = new HashSet&lt;Date&gt;();
	set.add(d1);
	set.add(d2);
	set.add(d1);
	System.out.println(set);
	</PRE>

Do you you see multiple occurrences of equal `Date` objects in the set?

**Based on your observations, what is the main difference between sets and lists?**

14. **Show your work to a TA.**

15. The story continues:  An `Appointment` has-a `Date` and a `Time`.

16. Design and implement an `Appointment` object in the `studio8` package.

17. Just as you did with `Date` and `Time`, use eclipse to generate the `hashCode()` and `equals(Object obj)`.  You should base these on equality of the contained `Date` and `Time` references.

18. Read over the code eclipse generates.  Note how it *delegates* equality to the contained objects, in which you have previously defined how you want equality treated for objects of those types.

19. Create some instances of `Appointment` objects using the `Date` and `Time` objects you have already made.

20. In your opinion, what other *has-a*s should an `Appointment` have?

21. **Show your work to a TA.**

22. Design a `Calendar`  object in terms of a collection of `Appointment`s.  

	* Should you use a list or a set?
	* What methods should your `Calendar` object offer?

23. Try to implement and test the methods of your `Calendar` object.

24. **Show your work to a TA.**

25. Let\'s add code so that a `Time` object offers the method `boolean isEarlierThan(Time other)` that returns whether `this` `Time` is earlier than the `other` `Time`, assuming the two occur on the same day.

26. Likewise, a `Date` offers the method `boolean isEarlierThan(Date other)`

	Implement and test these two methods.

	At this point, if implementation of these methods is difficult, revisit the way you specify and accept information for these classes.  You are free to design them to make your life easier.

27. **Show your work to a TA.**

28. Suppose we would like to offer a method common to both `Date` and `Time` that indicates whether you are working on the specified date or at the specified time.  Create an interface called `Working` with the single method:
	
	<PRE>
	  public boolean amWorking();
	</PRE>

29. Make both `Date` and `Time` implement that interface.

	You can be creative in terms of when you decide you are working, but here is a suggestion:

	* For `Time`, assume you are working between 9 AM and 5 PM
	* For `Date`, assume you are working on even-numbered dates

	
30. Create a list of `Working` objects and add up the number of those objects that indicate that you are working.

31. **Show your work to a TA.**