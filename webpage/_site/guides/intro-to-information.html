<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Introduction to Information Representation | CSE131: Computer Science I</title>
  <meta name="description" content="Computers are very different from humans[citation needed]. We’ve learned from experience that getting them to solve problems for us requires an extreme amoun...">

  <link rel="stylesheet" href="/cse131/_site/css/main.css">
  <link rel="canonical" href="https://www.cse.wustl.edu/cse131/_site/guides/intro-to-information.html">
  <link rel="alternate" type="application/rss+xml" title="CSE131: Computer Science I" href="https://www.cse.wustl.edu/cse131/_site/feed.xml">
</head>


<body>
	<div class="wrapper">
			<div class="container">

				<article class="site-content">
					<h1> 1: Introduction to Information Representation</h1>



					<p>Computers are very different from humans<sup>[citation needed]</sup>. We’ve learned from experience that getting them to solve problems for us requires an extreme amount of luck and translation, and popular culture likes to attribute that to computers “thinking differently” from us. While that’s certainly true, a lot of problems come from how we <em>store</em> information differently.</p>

<p>This guide explains how machines represent things, from the ground up, which is something we can’t quite explain for human information<sup id="fnref:biology"><a href="#fn:biology" class="footnote">1</a></sup>. First, we talk about the electrical signals we use for binary.</p>

<h2 id="binary">Binary</h2>

<p>At their very cores, modern (digital) machines store <strong>bits</strong> of information in the form of an electrical signal: on or off, <code class="highlighter-rouge">HIGH</code> or <code class="highlighter-rouge">LOW</code>, <code class="highlighter-rouge">1</code> or <code class="highlighter-rouge">0</code>. This sort of <strong>boolean</strong> information—information that can only be one of two values—is useful for questions like “yes or no?”, “shaken or stirred?”, “Pawnee or Eagleton?”, but not much else. Thankfully, we can use binary as a <strong>number system</strong>, just like decimal.</p>

<p>In order to <em>really</em> understand that, consider these two questions:</p>

<ul>
  <li>What is the number 4?</li>
  <li>What is the number 42?</li>
</ul>

<p>In the first case, the illuminating answer is very similar to the obvious one. <code class="highlighter-rouge">4</code> is a symbol we know to illustrate the concept of four items, just like the word <code class="highlighter-rouge">four</code> means the same thing.</p>

<p>In the second case, however, the interesting answer is a little more silly than the obvious one. <code class="highlighter-rouge">42</code> is two symbols: a <code class="highlighter-rouge">4</code> followed by a <code class="highlighter-rouge">2</code>. In this context, <code class="highlighter-rouge">4</code> <em>actually</em> means “four tens.” It is in the tens place. <code class="highlighter-rouge">2</code> still means “two,” or, “two ones,” since it is in the ones place.</p>

<p>You may recall an equation like this from grade school:</p>

<script type="math/tex; mode=display">42 = 4 \times 10 + 2 \times 1</script>

<p>There’s a tacit understanding that each consecutive digit in a number, from right to left, represents the next “place”: first the 1’s place, then the 10’s place, 100’s, 1,000’s, etc.</p>

<p>But where does this come from? You probably know offhand that we count in “base 10,” and therein lies our answer. “Base 10” implies that we have 10 counting symbols: <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">2</code>, <code class="highlighter-rouge">3</code>, <code class="highlighter-rouge">4</code>, <code class="highlighter-rouge">5</code>, <code class="highlighter-rouge">6</code>, <code class="highlighter-rouge">7</code>, <code class="highlighter-rouge">8</code>, and <code class="highlighter-rouge">9</code>. After that, our numerical system is, by itself, incapable of representing larger numbers. Hence this <strong>positional notation</strong>, where each consecutive number represents a different “place.”</p>

<h3 id="positional-notation">Positional Notation</h3>

<p>Unlike Roman numerals or even tally marks, which both stipulate simple addition of consecutive numbers (e.g. $XVII = X + V + I + I = 10 + 5 + 1 + 1 = 17$) , each consecutive number (from right to left) represents a multiple of a certain “place,” determined by the base you are counting in.</p>

<p>For example, in base 10, each “place” is an increasing power of 10: the number <code class="highlighter-rouge">452</code> represents two ones ($10^0$) plus five tens ($10^1$) plus four hundreds ($10^2$), because we have 10 symbols and cannot represent anything larger than 9 with just one number.</p>

<p>That same series of digits in base 6, then (to pick a random base), would be two ones ($6^0$), five <em>sixes</em> ($6^1$), and four <em>thirty-sixes</em> ($6^2$). This is because base 6 has <em>six</em> symbols, not 10, and <em>runs out of symbols</em> after 5. Because we are using positional notation, we therefore advance to the next place, which represents the next consecutive number.</p>

<p>Then apply this to binary—base 2. The number <code class="highlighter-rouge">1001</code> in base 2 represents the number we know of as <code class="highlighter-rouge">9</code> in base 10:</p>

<script type="math/tex; mode=display">1001_2 = 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 9</script>

<p>This should lead you to a couple interesting conclusions:</p>

<ul>
  <li>There must be <code class="highlighter-rouge">n</code> symbols for any base <code class="highlighter-rouge">n</code>. Base 2 has 2 symbols.</li>
  <li>Every place is exactly one greater than the maximum value of all the previous places combined: $100<em>{10}$ is one greater than $99</em>{10}$, and $1000_2$ is one greater than $111_2$.</li>
  <li>Shifting a number by adding or removing a place ($1,523 \leftrightarrow 15,230$) multiplies or divides it by the current base.</li>
  <li>It is tedious to count in base 2.</li>
</ul>

<p>If any of these observations do not make sense, I suggest spending more time thinking about different bases and how counting works.</p>

<h2 id="hexadecimal">Hexadecimal</h2>

<p>Computer scientists have long known the tediousness of base 2. Simple numbers become very long: it takes 10 places to represent all the numbers less than $1000_{10}$! So most of the time when dealing with computer-numbers we write in <strong>hexadecimal</strong>—hex.</p>

<p>Hexadecimal is base 16. Base 16 requires 16 symbols, so we take all the base 10 digits, 0-9, and add <code class="highlighter-rouge">A=10</code>, <code class="highlighter-rouge">B=11</code>, <code class="highlighter-rouge">C=12</code>, <code class="highlighter-rouge">D=13</code>, <code class="highlighter-rouge">E=14</code>, and <code class="highlighter-rouge">F=15</code>. Since the base is 16, each place is a power of 16: $100<em>{16} = 256</em>{10}$. Therefore, the number $1B_{16} = 27_{10}$.</p>

<p>We typically prefix hex numbers with <code class="highlighter-rouge">0x</code> to identify them, like <code class="highlighter-rouge">0x4a41</code>. You can convert any binary to hex by taking each block of 4 binary digits and finding the corresponding hex digit, starting from the right:</p>

<script type="math/tex; mode=display">1 1010 1110 1001 1001 = 0x1AE99</script>

<h2 id="ints-and-the-things-youre-used-to">Ints and the things you’re used to</h2>

<p>Now that we’ve dispensed with the more abstract mathematics, reality comes into play. Consider why we use <em>binary</em> in computing: we only have two possible signals, <code class="highlighter-rouge">HIGH</code> and <code class="highlighter-rouge">LOW</code>. It is not physically possible to use any higher base.</p>

<p>We also run into another problem. How can we indicate when a number <em>ends</em>? In the human world, this is not a problem: we simply stop writing, make a new line, and write another number. However, this secretly introduces another symbol—some way of demarcating the end of a number. We do not have this extra symbol, unless we count in base 1, which is basically tally marks<sup id="fnref:whynot"><a href="#fn:whynot" class="footnote">2</a></sup>. Therefore, we assign limits to the size of our numbers.</p>

<p>This is the reason we have <code class="highlighter-rouge">int</code>s. <code class="highlighter-rouge">int</code>s store whole numbers in base 2 but have a maximum size<sup id="fnref:minsize"><a href="#fn:minsize" class="footnote">3</a></sup>. Java is more exacting: <code class="highlighter-rouge">int</code>s are 4 bytes (a <strong>byte</strong> is a 8 <strong>bits</strong>, digits of binary: $4 \times 8 = 32$ bits), whereas C <code class="highlighter-rouge">int</code>s are <em>at least</em> 2 bytes ($2 \times 8 = 16$ bits). If you want 4 bytes in C, you use a <code class="highlighter-rouge">long</code>.</p>

<h2 id="signed-unsigned-and-fixed-point">Signed, unsigned, and fixed point</h2>

<p>We have two other non-digit symbols that we need to represent with our two symbols: the <strong>negative sign</strong> and the <strong>decimal point</strong>.</p>

<h3 id="negativity">Negativity</h3>

<p>The simplest solution is to ignore negative numbers entirely. Don’t store anything negative. That is what <code class="highlighter-rouge">unsigned</code> numbers do, in both Java and C: an <code class="highlighter-rouge">unsigned int</code> in Java is exactly what you would expect, and can represent all numbers from 0 to $2^{32}-1 = 4,294,967,295$<sup id="fnref:obvious"><a href="#fn:obvious" class="footnote">4</a></sup>.</p>

<p>This will not do, because sometimes we need to work with negative numbers. Several “quick fixes” come to mind: <strong>biased representation</strong>, where where you subtract an implied number <code class="highlighter-rouge">K</code> from any negative number, so an unsigned <code class="highlighter-rouge">0</code> becomes <code class="highlighter-rouge">-K</code>. This number <code class="highlighter-rouge">K</code> is usually half the maximum value, so that a number can be <strong>equally biased</strong>, with equal negative and positive numbers. This is not used in most circumstances, and neither is <strong>sign-magnitude</strong>, which uses the highest bit as a negative “flag”— <code class="highlighter-rouge">HIGH</code> and the number is negative, <code class="highlighter-rouge">LOW</code> and the number is positive<sup id="fnref:why"><a href="#fn:why" class="footnote">5</a></sup>.</p>

<p>Instead, all modern computers use <strong>two’s complement</strong> to represent signed numbers. If a number is <code class="highlighter-rouge">signed</code> rather than <code class="highlighter-rouge">unsigned</code> (by default, almost every number is <code class="highlighter-rouge">signed</code> in Java and C), the <strong>most significant bit</strong>—the binary digit in the largest place (the <code class="highlighter-rouge">1</code> in <code class="highlighter-rouge">1,000,000</code>)—represents a <em>negative version of itself</em>. For example, in traditional, unsigned binary:</p>

<script type="math/tex; mode=display">110_2 = 1 \times 2^{2} + 1 \times 2^{1} + 0 \times 2^0 = 5</script>

<p>In <em>two’s complement</em>:</p>

<script type="math/tex; mode=display">110_2 = 1 \times -2^{2} + 1 \times 2^{1} + 0 \times 2^0 = -1</script>

<h3 id="fixed-point">Fixed-Point</h3>

<p>Now what about decimals? If you’re handling something like money, fixed-point notation works great. It’s about as simple as you might expect.</p>

<p>In whole numbers, there is an implied decimal point at the end:</p>

<script type="math/tex; mode=display">1,502 = 1,502.0 = 1 \times 10^3 + 5 \times 10^2 + 0 \times 10^1 + 2 \times 10^0 + 0 \times 10^{-1}</script>

<p>Note the last entry in the expanded form: $0 \times 10^{-1}$. Numbers after the decimal point work just like numbers before it in terms of positional notation: $0.51 = 0 \times 10^0 + 5 \times 10^{-1} + 1 \times 10^{-2}$.</p>

<p>So a fixed-point system just moves the implied decimal point over. Fixed-point numbers are not used much, but we describe fixed-point numbers using <strong>Q notation</strong>: a <code class="highlighter-rouge">Q</code>, followed by the number of pre-decimal point digits, followed by the number of post-decimal point digits. <code class="highlighter-rouge">Q1.15</code> holds one integer bit and 15 fractional bits. We will use this representation later in the semester.</p>

<p>There is very little native support for fixed-point numbers.</p>

<h2 id="floating-point">Floating Point</h2>

<aside class="sidenote">
  <h3 id="floating-pointless">Floating Pointless</h3>

  <p>Floating-point numbers are extremely complicated, with special codes for <code class="highlighter-rouge">NaN</code> (not a number), infinity, and two forms of zero. Floats can also store numbers in <strong>denormalized form</strong>, a format that almost completely changes the specification you learn here.</p>

  <p>They have at least 5 different <strong>rounding modes</strong>, are not transitive (<code class="highlighter-rouge">3.14 + (1e10 - 1e10) != (3.14 + 1e10) - 1e10</code>), have positive and negative zero, and quirks galore.</p>

  <p>If that seems awesome and worth learning about, great! Take 361S or any Operating Systems/Computer Architecture course.</p>

  <p>If that seems pedantic and confusing, don’t worry. We only care that you know <code class="highlighter-rouge">float</code>s are scientific notation, how the memory for one is ordered and used, and that they can be imprecise at times.</p>
</aside>

<p>Fixed-point isn’t very well supported because it has limited use. In math, you don’t always know how many decimal points you want at any given time. The whole idea of <strong>scientific notation</strong> stems from debate on how to sensibly be able to represent <code class="highlighter-rouge">1,200,000,000</code> and <code class="highlighter-rouge">0.017</code>, multiply them, and make sense of how accurate the resultant number is.</p>

<p>Rather than reinvent the wheel, we just went ahead and implemented scientific notation in binary. Given a certain number of bits, we assign some of them to be the <strong>mantissa</strong> (the “number” part of a scienfitically-notated number), and some to be the <strong>exponent</strong>. Then, we throw out everything we said about sensible representation in the section on negativity, add a <strong>sign bit</strong> to represent the negativity of the mantissa, bias the exponent, and throw them together:</p>

<script type="math/tex; mode=display">(-1)^{sign} \times mantissa \times 2^{exponent - bias}</script>

<p>The IEEE decides how <code class="highlighter-rouge">float</code>s can be implemented. The standard <code class="highlighter-rouge">float</code> has:</p>

<ul>
  <li>1 <strong>sign</strong> bit, followed by</li>
  <li>8 <strong>exponent</strong> bits, followed by</li>
  <li>23 <strong>fractional</strong> bits.</li>
</ul>

<p>If you know scientific notation, the mantissa can <em>never</em> have a zero as its first number (e.g. <code class="highlighter-rouge">0.626e-6</code> is not valid scientific notation). Since their is only one alternative in binary, the <code class="highlighter-rouge">1</code>, all binary mantissas must start with a <code class="highlighter-rouge">1</code> (<code class="highlighter-rouge">1.000111e-100</code>). This is implied and is left out of the data, hence the name <strong>fractional</strong> bits, not “mantissa” bits. The mantissa for a <code class="highlighter-rouge">float</code> therefore actually holds 24 bits-worth of actual information.</p>

<h2 id="text--ascii">Text &amp; ASCII</h2>

<p>If you have actually gotten here, I suggest going to Chapter 7 of Chamberlain’s textbook for more.</p>
<div class="footnotes">
  <ol>
    <li id="fn:biology">
      <p>CS dept: 1, Bio: 0 <a href="#fnref:biology" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:whynot">
      <p>We <em>don’t</em> do this because then it becomes very hard to read long numbers: we could theoretically use <code class="highlighter-rouge">LOW</code> as the “end” of our number, but then the computer would literally have to read memory until it reached such a <code class="highlighter-rouge">LOW</code> just to know the size of a number. This leads to all sorts of problems, especially if you understand the mechanics of Turing machines (take a “theory of computing” course if you are interested). One of them is that it would therefore take <code class="highlighter-rouge">n</code> operations to read the number <code class="highlighter-rouge">n</code>. Considering computers regularly need to work with numbers larger than a billion and our best ones only do about 3 billion operations per second, that’s a problem. <a href="#fnref:whynot" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:minsize">
      <p>The C specification itself does not actually specify this size. It specifies a <em>minimum</em> size, i.e. <code class="highlighter-rouge">int</code>s need to be able to hold <em>at least</em> a certain number, but sometimes a machine makes <code class="highlighter-rouge">int</code>s larger. Using anything larger than the C specification’s maximum number may therefore do different things on different machines, something we call <strong>undefined behavior</strong>. Do not make your programs do undefined things unless you know what you’re doing. <a href="#fnref:minsize" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:obvious">
      <p>Think a little more about positional notation if that doesn’t make sense. What’s the maximum number, in base 10, you can represent with 4 digits? Can you represent that as $10^{x}-1$? <a href="#fnref:obvious" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:why">
      <p>People fought tooth and nail over this when computers were first getting started, arguing between sign-magnitude, two’s complement, and an additional one’s complement. Sign-magnitude was first out because it could not store the same range of values (a whole bit was dedicated solely to storing positive or negative, and you can eke out another value with the other two), and one’s complement lost because it had two forms of the number <code class="highlighter-rouge">0</code>, like sign-magnitude. Two’s complement only has one form of zero and is easier to do computation with, so it won the battle. <a href="#fnref:why" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

				</article>
			</div>

	</div>
	<script type="text/javascript" src="/cse131/_site/js/highlight.pack.js"></script>
</body>
</html>