---
title: "Zombies: A Method to their Madness"
week: 5
---

You can access the repository for this assignment <a href="" target="_blank">here</a>. When importing the project be sure to:
1. Close all projects (in every open IntelliJ window pick `File > Close Project`)
2. Once you get back to the initial IntelliJ window (small square box):<br/>![IntelliJ Start Window](../../../assignments/IntelliJStartWindow.png){:width="50%"} <br/>select the `Check out from Version Control` option.
3. Use the repo URL
4. As you step through the import process **give each window a second to search for the required resources**.


# More Zombies: There's a *METHOD* to their Madness!

This assignment is a follow-up to Lab 4, where you wrote code that could read a data file and display entities being simulated.  Here you'll build on Lab 4 in two ways:

* Now that we have a new technique, methods, you'll take your prior work and adjust it to work well with methods.
* You'll extend it with additional methods and complete the basic zombie simulator.

# Practicing New Techniques

## Refactoring

[Refactoring](https://en.wikipedia.org/wiki/Code_refactoring){:target="_blank"} is a technique used to refine computer code.  The basic idea is to restructure code without changing overall behavior.  Often refactoring is done because either: a) code is difficult to manage (too complex) and reorganizing it will make it easier to update/fix/understand or b) new techniques provide better ways of writing the code.  If you completed Lab 4 you can simplify your work here by simply refactoring some of your Lab 4 work.

## Methods

Methods are a fundamental part of computing because:

* They allow us to break complex problems into smaller, more manageable parts.  It makes it possible for a single person to write a complex program by working on one small part at a time and ensuring that the small parts can be combined together.
* They allow code to be re-used.  In this case we will do some operations repeatedly and rather than copying/pasting code you can just write a method once (one copy of the code) and call it as-needed.

## Method Return Values

Methods can only return a single "thing", but often we'd like to return multiple things. For example, we'd like to use a method for reading in an entire file for our simulation, however, in Lab 4 we stored that data in three distinct one dimensional arrays.  Here we'll instead use a single two dimensional array of `double`s to contain all of our data.  Like before, each row will represent a single item.  Rather than using different arrays for the `type`, `x` coordinate, and `y` coordinate, we'll instead use three columns of a two dimensional array. Column 0 will contain the type, column 1 will contain the x coordinate, and column 2 will contain the y coordinate. 

## "Magic" Numbers and Constants

The term [Magic Number](https://en.wikipedia.org/wiki/Magic_number_(programming)) is often used when program code includes numbers that represent special codes.  For example, we're using the number 2 to indicate the column containing a y coordinate.  The number 2 would be considered a "magic number" because it's an arbitrary choice and may not be clear to someone who reads your code. 


In order to make our code more readable we'll use special variables for the indices rather than the "Magic Numbers".  The lab file already contains the three lines:

~~~java
static final int TYPE = 0;
static final int X = 1;
static final int Y = 2;
~~~

These three lines declare variables that represent the column that will contain the type, the column that will contain the X coordinate and the column that will contain the Y coordinate.  *Anytime* a location in the 2D array is used one of these variables should be used to make your code easier to read.  For example, when someone reads:

~~~java
int a = (int)anArray[i][1];
int b = anArray[i][0];
~~~

it isn't very clear that the `0` is the type and the `1` the X coordinate (they are magic numbers).   The following is easier to read and less prone to errors:

~~~java
int a = (int)anArray[i][X];   // Note the column is indexed with "X"
int b = anArray[i][TYPE];     // and this column is inexed with "TYPE"
~~~

Of course, using better variable names make it even more readable:

~~~java
int x = (int)anArray[i][X];
int type = anArray[i][TYPE];
~~~

The lab assignment also includes:

~~~java
static final int ZOMBIE = 1;
static final int NONZOMBIE = 2;
~~~

The words `ZOMBIE` and `NONZOMBIE` should always be used in code rather than the numbers `1` and `2` because things like: `if(entities[i][TYPE] == ZOMBIE)` are a lot easier to read/write (less prone to errors) than: `if(entities[i][0]==1)`.

# Double Buffering 

You may have noticed in the Lab 4 that it's possible to see each individual entity being drawn.  This is because drawing on the screen takes a little bit of time. If we're able to see each entity being drawn the simulation will seem slow and jerky. 

[Double Buffering](https://en.wikipedia.org/wiki/Multiple_buffering) is a technique used to make animations look smooth.  The basic idea is to have two different "frames" (the two buffers).  At any given time one is being shown on the screen and any new drawing takes place on the other one, which isn't being shown.  These two frames are switched and, from the point of view of anyone looking at the screen, a lot of changes take place instantaneously. A sequence of these changes can show an animation in the same way a [flip book](https://en.wikipedia.org/wiki/Flip_book) works ([Sample Video on Wikipedia](https://en.wikipedia.org/wiki/File:Flip_Book_-_Messi_Example.webm)).  Much like a flip book, all visible items are drawn in each frame, but the positions of items that are moving change a tiny bit from one frame to another. 

`StdDraw` supports double buffering by the following approach:

1. When the program first starts (in `main`) call [`StdDraw.enableDoubleBuffering()`](https://introcs.cs.princeton.edu/java/stdlib/javadoc/StdDraw.html#enableDoubleBuffering--)
2. Whenever it is time to change frames:

~~~java
StdDraw.clear();  // Clear the non-shown frame
// Draw *all* objects in their locations (which may have changed from the last frame)
StdDraw.show();  // Swap the non-shown frame with the one being shown on screen.
~~~

# Unit Testing

The final new topic for this lab is a review of [unit testing](https://en.wikipedia.org/wiki/Unit_testing).  As you complete each part of this lab you will test that part.  If all the parts work in the intended way there's a much greater chance that they will work when combined together.  

**Special Note: Unit tests help developers make sure the code works, but they usually only test a relatively small number of possible conditions. NEVER assume that code that pasts unit tests "must work".  The test only ensure that it did what those tests expected.  The tests themselves could be flawed or they may not test a set of conditions that will fail!**




# Recommended Work Flow



# Assignment Requirements

Your work needs to:
1. Prompt users for the name of the file that will include the initial locations of entities.
2. Read all the information from that file and store it in parallel arrays.  Use Sedgewick's [`In`](https://introcs.cs.princeton.edu/java/stdlib/javadoc/In.html){:target="_blank"} API. 
3. Display all the elements in the simulation using Sedgewick's [`StdDraw`](https://introcs.cs.princeton.edu/java/stdlib/javadoc/StdDraw.html){:target="_blank"}.
   * For full credit you *must* read in all entites and store them in arrays *before displaying anything*.  (This structure will make future assignments easier)
   * Zombies should be displayed with filled red circles with a radius of `0.005`.
   * Non-Zombies should be displayed with filled black circles with a radius of `0.005`.

# Procedure

* Open the `ZombieData` in the `lab4` package.  Some items have already been done for you.  Most of the remaining work is labeled in the file with `TODO` comments.
* Prompt the user for the file name to use with the `ArgsProcessor`.
* Review Sedgewick's [`In`](https://introcs.cs.princeton.edu/java/stdlib/javadoc/In.html){:target="_blank"} API.  It can be used almost exactly like you use the `ArgsProcessor`.  An `inFile` object has already been created for you.
* Read in the first line of the file (the `N`)
* Create arrays of appropriate size (for the "parallel data").
* Read in each additional piece of data.  Remember the format: `int`, `double`, `double`
* Display all the entities using [`StdDraw`](https://introcs.cs.princeton.edu/java/stdlib/javadoc/StdDraw.html){:target="_blank"}.

# Submitting your work:

To submit your work, contact the instructor or a TA. They will walk you through the submission process. Be prepared to show them the work that you have done and answer their questions about it!
