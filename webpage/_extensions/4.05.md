---
name: Roving Eyes
week: 4
number: 5
points: 10
---

Authors
: <a href="http://www.cs.wustl.edu/~cytron/">Ron K. Cytron</a>
: Ken Goldman

> A video demonstrating my solution can be found <a href="../../../extensions/rovingeyes.mp4">here</a>.

Although the solution can be quite short (mine weighed in at approximately
50 lines), there are some tricky aspects to this work, and it may be an
extension that you work on over several weeks.

You will have to interact with the mouse, perhaps for the first time, both
in terms of its location and determining whether the mouse has been pressed and
released.  It will take patience to get this to work, but most students like
the end result.

##The idea

* Each time the mouse is clicked, an eyeball is deposited on the image.

* Each eyeball consists of two parts:

	* An outer filled circle that is white with a thin black border.  This part
			of the eyeball does not move as the mouse moves around the screen.
			
	* An inner filled circle with of some color (mine are red, below). This part of the eyeball does move, so that the eyeball can appear to be looking at something.

* All eyeballs seem to look at the mouse, wherever the mouse moves within the `StdDraw` window.


| ![](../../../extensions/ken1.png) | ![](../../../extensions/ken2.png) | ![](../../../extensions/ken3.png) | ![](../../../extensions/ken4.png) |
| This is the initial image you should draw. The picture can be found as `images/ken.jpg` in your workspace. | Here, I have clicked over the image to deposit my first eyeball. The mouse (not shown) is to the right, so the eyeball is looking that way. | Then I clicked a second time to deposit another eyeball, this time over the right eye shown in the image. Both eyeballs are looking at my mouse, which is at the lower right (not shown). | Each time I click the mouse, another eyeball is deposited, and all eyeballs continue looking at my mouse, wherever it happens to be.

## Part 0: Initialize your application

* Begin by drawing the picture in the image.

* Prompt the user to specify the maximum number of eyeballs that will be drawn.  This information is necessary so that you can appropriately provision arrays needed to implement this extension.

	This code is included in your repository.  Open the
	`extensions` folder in which you will find the `eyeballs`
	package. Open and run the `Eyeballs` class.

## Part 1:  Detecting mouse clicks
Most programs that interact with the mouse use a *listener* model that
takes action when the mouse is moved, pressed, released, or clicked (a press
and release action).

Unfortunately, in Sedgewick\'s API, we can only determine the current
status of a mouse button as up or down.  We must then use logic and
iteration to discover whether a mouse has been pressed, released, or 
clicked.

This low-level API for the mouse leads to
some mixed feelings about how you are learning to interact with the mouse:

* The code you write will not be typical of how most Java programs
	interact with the mouse.  The reason for this is that your work takes
	place in an infinite loop, slowed only by the use of `StdDraw.pause(n)`,
	which consumes resources on your computer even when you are not moving
	the mouse.
	
* You are essentially *polling* the mouse as to whether it
	is up or down, and then using your own logic to determine whether
	it has been pressed, released, clicked, or dragged.  
	From a pedagogical perspective, you
	will learn how this kind of processing takes place at a low level on some
	computers.  You also learn how to track the *state* of an input device
	over time, and many applications require this kind of logic.

Following is a description of mouse actions as they are typically 
used in most applications:

Mouse press

: We think of this as a single push-down action on a mouse or trackpad. This action usually initiates some activity in applications.  

From an application\'s point of view,
this event
happens just once when the mouse is pushed down.  Generation of another mouse
press action would require the mouse to be released, and then pressed again.


Mouse release

: If a mouse has been pressed, then it can be released.  Some applications distinguish between the press and release, so that the mouse can move between those actions.  This is sometimes called <I>dragging</I> the mouse.


Mouse click

: While this is a compound action, consisting of a mouse press followed by a mouse release, it is usually treated as an atomic action that takes place at exactly one coordinate.  The release also happens within some reasonable timeframe of the press, if the press and release are to be construed as a click.

The above mouse actions are the logical ones that we wish
to implement.  Actually, it suffices for this extension to
determine only a mouse release, but you are welcome to think about how to
discover the other actions.

The Sedgwick API offers only the following interface, which
we must use in our application to simulate the above mouse actions.

  
`double mouseX()`

: returns the x-coordinate of the mouse, expressed in terms of the coordinates of the `StdDraw` canvas.

  
`double mouseY()`

: returns the y-coordinate of the mouse, expressed in terms of the coordinates of the `StdDraw` canvas.

  
`boolean mousePressed()`

: A better name for this would be `boolean isMouseDown()`, because
this method does not detect a mouse press in the standard view of mouse
actions.  Instead it simply reports whether the mouse button is currently 
pressed or not.

Your task is to simulate a mouse-click action using the above API.  
This will inevitably involve *polling* the mouse as to whether the
button is down or up.  Consider the following code:

	while (!StdDraw.mousePressed()) {
		// do nothing, 
		// we are waiting for the mouse button to go down  
		//
		// The line below is important, as described below
		//
		StdDraw.show(50);
	}

* Without the pause using `StdDraw.show(50)`, this application 
	would run in a *tight* loop
	that would always keep your computer busy, even if you are not interacting
	with the application.   As a result, all of the other applications open on your
	computer would suffer from not getting sufficient CPU resources to be
	reponsive.  These applications would appear to behave sluggishly.
	
* Sedgewick uses the pause intervals to hide updates that you make to
	the drawing canvas.   Between calls to show, no updates are shown.
	At the call to show, the screen is redrawn, and the CPU is released
	for the specified period of time (50 milliseconds in the above code).

Make sure your eyeballs are depositing properly as you mouse-click before
you move on to implement more features.

## Part 2: Following the mouse movement

A pupil within an eyeball tracks objects using the geometry of similar
triangles.  The following diagram and discussion may be useful.

![](../../../extensions/eyeball.png)

* The eyeball is centered at `(ex,ey)` and is looking at the
	object (the mouse) at `(mx,my)`.  
	This leads to the following equations:
	
	* `mx = ex + dx`
	* `my = ey + dy`

* Knowing `(ex,ey)` and `(mx,my)`, we can solve
	for ` dx` and `dy`.

* Knowing `dx` and ` dy`, we can 
	compute `d` using the distance formula.

* We know `p`, because it is the radius of the eyeball minus
	the radius of the pupil.  This may be hard to see, but convince yourself
	of this by looking carefully at the figure.

* The green triangle is similar to the large triangle.

* Knowing ` p `  and `d`, we can compute their ratio.

* That same ratio describes 

	`px`:`dx`
	`py`:`dy`.
	
* From those ratios we can compute ` px` and ` py`.

* Knowing `(ex,ey)`, `px`, and `py`, we can
	compute the center of the red pupil as `(ex+px,ey+py)`.

## Putting it all together

Your code is like the bouncing ball code, in that it enacts a sequence
of frames.  Each frame consists of checking whether and where a new eyeball
should be deposited.  Moreover, all existing eyeballs must be updated so
that they appear to be tracking the mouse as it moves through the window.

Give yourself time for this extension, and develop and test the aspects
in the order described above.