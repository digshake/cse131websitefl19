---
name: Objects to Support Music
week: 7
number: 5
points: 9
---

##Overview:

There are several extensions that involve the use of music.  Without some nicely articulated objects in place, the code for those extensions would become unwieldy.

This extension involves your completing some classes that have already been designed.  Each class has an API described here and in the class\'s JavaDoc comments.  A JUnit test case is written both to help you create a correct implementation of the design and to demo your work for credit.

##Before Starting:

* Update your workspace and look for the `chords` packages in
the `extensions` source folder, which include the following

`chords.gui`

This package has objects that are provided for your use.  You do not need to make any changes to these classes.

Later, the class you will most likely use from this package is `TwoDimensionsionalGUI`,  which helps applications use the current position of the mouse in the Sedgewick drawing panel as a control mechanism.

For now, run the provided `TwoDimensionalGUIExample` and watch the effects of moving your mouse around in the window.  This code uses the `TwoDimensionalGUI`\'s `update()` method in an event loop, such as the ones you have seen before that accomplish animation.

`chords.testing`

This package contains the tests for the code you will develop. Most of them are JUnit tests, but one (`PlayTest`), is an application that you will run to test your code.

`chords.music`

This package contains skeleton classes for the code you will develop. Follow the instructions below, in the order given, to simplify your efforts.

##Development Sequence

Some general guidelines follow:

1. Pay attention to the *user story* told about each class.  Recall that each *has-a* indicates the need for an instance variable.

2. Name your variables appropriately, and protect them from access by other classes by declaring them `private`.

3. Where appropriate, include `final` on the declaration of instance variables, so that their values cannot be changed after the constructor finishes.

4. Create meaningful `toString()` methods.  Make sure these do not produce *too* much information.  For example, if a class contains a large array of values, those should not be included in the `toString()` result.  Instead, include the size of the array in the `toString()` result if it could be useful.

OK, now follow the steps below, **in order**, to develop the classes for this extension:

1. Open the `Samples` class as we will complete this class first.

2. Take a look at the first constructor in `Samples`- the one whose signature is `Samples(double[])`.

	A `Samples` object *has-a* `double` array of samples. This constructor takes in such an array, and the constructor must capture the array **by making a copy of its values** to be retained as an instance variable.

	This is a bit unusual:  you would normally capture an instance variable `val` by writing `this.val = val`, but for an array, that would retain the *reference* to the array without copying its values. While the reference is sufficient to access the array\'s values, there is no guarantee that code outside the `Samples` class won\'t change the array after the constructor returns.

	To guard against this, your constructor must make a *copy* of the array\'s values.  As a reminder, this involves:

	1. Declaring the instance variable to be an array of `double` values.
	
	2. In the constructor, instantiating the array the be the same size as the parameter array\'s size.
  
	3. After instantiating the array, writing a loop to copy the values one-by-one from the parameter into the instance variable copy.

	The `testConstructor1()` test will not pass until you have also completed `getNumSamples()` and `getSample(int i)`, so once you have completed the constructor, we advise that you complete these two simpler methods before unit testing again. 

3. Implement the `double getSample(int)` method, which should return the value of sample `i`.   Note that `getSample(0)` returns the first value, because (like most things in Java), we begin our samples at index `0`.

4. Next complete the `getNumSamples()` method by returning the length of the instance-variable array of samples.

	Run the unit tests, and the `testConstructor1()` unit test should pass at this point, as well as the `getNumSamples()` unit test

5. The second constructor for `Samples` has signature `Samples(int)`. It does not accept an input array, but instead it should instantiate the instance variable to be an array of the specified `length`, all zero.  Such an array is not not directly useful or suitable for play-back, but is useful as a base for composing or extending other samples. Java does initialize all newly instantiated `double` arrays to zero automatically.
 
	This constructor also requires `getNumSamples()` and `getSample(int i)` to be completed before it will pass `testConstructor2`.

6. Complete the `play()` method by having Sedgewick\'s `StdAudio` class play the instance-variable array of samples.

7. Complete the `toString()` method to return a useful string to describe the contained samples.

8. Complete the `getMax()` and `getMin()` methods so that they do what their comments say they should do.

	Run the unit tests, and the `testMax()` and `testMin()` unit tests should pass at this point.

9. Complete the `concat(Samples)` method, which takes `this` sequence of samples and an `other` sequence of samples and return a new sequence that is the concatenation of the two. Note that this must return a `new Samples` object.  The current object must not be changed!

	Run the unit tests, and the `testConcat()` unit test should pass at this point.

10. Complete the `combine(Samples)` method, which takes `this` sequence of samples and an `other` sequence of samples, and sums them, element-by-element, to form a new sequence of samples. If one sequence is shorter than the other, it is as if the shorter sequence had zeros as the sums are computed.

	Run the unit tests, and the `testCombine()` unit test should pass at this point.

11. OK after all that work, open `Pitch` and you will see that this class is done for you.

	Run the `PitchTest` unit tests, and they should pass at this point.


12. Open the `SingleTone` class.  A `SingleTone` *has-a* frequency which should be retained as a `double`.

13. Complete the constructor for `SingleTone`.

14. Complete the method `getSamples()` by generating samples at the specified `amplitude` and `duration`. Recall that a `SingleTone` *has-a* a frequency, so the
frequency used for the samples should be stored as an instance variable in your class.

15. Complete the `getOverTone(double)` method, which returns a new `SingleTone` object whose frequency is the specified mutliple of `this` one\'s frequency.

16. Complete the `getOverTone(int,int)` method, which should return its result by reduction to the `getOverTone(double)` method. This means that you should return the result of `getOverTones(int,int)` by returning a suitable call of `getOverTone(double)`.

	Run the unit tests, and the `testOvertones()` unit test should pass at this point.

17. Open `DiatonicScale`.  This class represents notes that form a major scale, such as the natural (usually, white) keys do on a piano.  A `DiatonicScale` *has-a* starting `Pitch`, which should be retained as a `Pitch` reference.

	We could have designed this class to retain the starting pitch as an integer, but with the richer object `Pitch` we should use it instead.

	Why?

	A `Pitch` object can easily compute other related pitches, and return its representation as a frequency.   We could carry out these computations on any integer, but by having it already programmed in `Pitch`, we should use that object to avoid code duplication, avoid work, and increase reliability.

18. The first constructor is already completed in terms of the second one, so you don\'t have to worry about the first constructor.

19. The second constructor must be completed, but it simply stores its incoming parameter in the instance variable you provisioned above.

20. Let\'s look at `getPitch(int)`.  This method returns the `Pitch` that is the specified diatonic distance from this `DiatonicScale`\'s starting pitch.  What makes this tricky is that the diatonic notes are not evenly spaced.  This can be most easily understood by looking at the chromatic distances between the natural keys on a piano. The following table shows the relative chromatic distances between the notes of a diatonic scale:

	<TABLE BORDER>
	<TR> <TH> Example in <br>key of C major</TH> <TH> Diatonic<br>offset` <TH> Chromatic offset<br> from previous<br> diatonic note</TH> </TR>
	<TR> 
	  <TD > C </TD> 
	  <TD > 0 </TD> 
	  <TD > N/A </TD> 
	</TR>
	<TR> 
	  <TD > D </TD> 
	  <TD > 1 </TD> 
	  <TD > 2 </TD> 
	</TR>
	<TR> 
	  <TD > E </TD> 
	  <TD > 2 </TD> 
	  <TD > 2 </TD> 
	</TR>
	<TR> 
	  <TD > F </TD> 
	  <TD > 3 </TD> 
	  <TD > 1 </TD> 
	</TR>
	<TR> 
	  <TD > G </TD> 
	  <TD > 4 </TD> 
	  <TD > 2 </TD> 
	</TR>
	<TR> 
	  <TD > A </TD> 
	  <TD > 5 </TD> 
	  <TD > 2 </TD> 
	</TR>
	<TR> 
	  <TD > B </TD> 
	  <TD > 6 </TD> 
	  <TD > 2 </TD> 
	</TR>
	<TR> 
	  <TD > C </TD> 
	  <TD > 7 </TD> 
	  <TD > 1 </TD> 
	</TR>
	</TABLE>

	Moreover, the `getPitch(int)` method must accommodate values for its parameter that are negative, zero, or positive, and those values maybe outside the range of a single octave.

	This is the trickiest method:  get help from the TAs or instructor if you need it.


	* Run the unit tests for `DiatonicScale` and they should pass at this point.
	* You can also run `DiatonicScale` as an applicaiton and it should print out some information about some scales.

21. Open `Triad` class.  A `Triad` has three `SingleTone`s.  

22. Complete the constructor for `Triad`. The constructor takes in a `DiatonicScale` and an `int`, which is the diatonic offset of the root of the triad.

	The other two pitches are 2 and 4 diatonic offsets away from the root.

	Use the `getPitch(int)` method of the specified `DiatonicScale` to find the root, second, and third `SingleTone`s of this `Triad`. 

23. Complete `getTones()` which returns an array consisting of the `SingleTone`s of this `Triad`, in order.

24.  Complete `getSamples(double,double)`, which returns a `Samples` object of the triad\'s tones at the specified amplitude and of the specified duration.  

* Note that the specified amplitude must be divided (evenly) among the three `SingleTone`s.   
* All three `SingleTone`s of the triad should sound simultaneously and last for the specified duration.
* This method can be written in a single line of code using objects you have already created and tested.


Run the unit tests for `Triad` and they should pass at this point.

For your final test, run `PlayTest` and choose a song.  You should be able to hear the song repeat and with the mouse you can change its pitch and its speed.
